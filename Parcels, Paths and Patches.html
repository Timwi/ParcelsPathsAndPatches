<!DOCTYPE html>
<html>
<head>
	<link rel='stylesheet' type='text/css' href='Parcels,%20Paths%20and%20Patches.css'>
	<script>
		let w = 9, h = 9, coroutines = {}, counter = 0, inputBlocked = false, stepsWithThumbnails = [1, 3];

		let Easing = {
			InQuad:	t => t * t,
			OutQuad:	t => -t * (t - 2),
			InOutQuad:	t => 2 * (t < .5 ? t * t : (2 - t) * t - 1),
			InCubic:	t => t * t * t,
			OutCubic:	t => ((t - 3) * t + 3) * t,
			InOutCubic:	t => t < .5 ? 4 * t * t * t : ((4 * t - 12) * t + 12) * t - 3,
			InQuart:	t => t * t * t * t,
			OutQuart:	t => (((4 - t) * t - 6) * t + 4) * t,
			InOutQuart:	t => t < .5 ? 8 * t * t * t * t : (((32 - 8 * t) * t - 48) * t + 32) * t - 7,
			InQuint:	t => t * t * t * t * t,
			OutQuint:	t => ((((t - 5) * t + 10) * t - 10) * t + 5) * t,
			InOutQuint:	t => t < .5 ? 16 * t * t * t * t * t : ((((16 * t - 80) * t + 160) * t - 160) * t + 80) * t - 15,
			InSine:	t => -Math.cos(t * Math.PI / 2) + 1,
			OutSine:	t => Math.sin(t * Math.PI / 2),
			InOutSine:	t => .5 - Math.cos(Math.PI * t) / 2,
			InExpo:	t => Math.pow(2, 10 * (t - 1)),
			OutExpo:	t => 1 - Math.pow(2, -10 * t),
			InOutExpo:	t => t < .5 ? Math.pow(2, 10 * (2*t - 1))/2 : 1 - Math.pow(2, -10 * (2*t - 1))/2,
			InCirc:	t => 1 - Math.sqrt(1 - t * t),
			OutCirc:	t => Math.sqrt((2 - t)*t),
			InOutCirc:	t => t < .5 ? (1 - Math.sqrt(1 - 4*t*t))/2 : (Math.sqrt((8 - 4*t) * t - 3) + 1)/2
		};

		async function coroutine(id, data, fnc)
		{
			let val = coroutines[id] = counter++;
			counter %= 2147483647;
			for (let ix = 0; ix < data.length; ix++)
			{
				if (typeof data[ix] === 'function')
				{
					await data[ix]();
					continue;
				}
				let startTime = await new Promise(requestAnimationFrame), elapsed = 0, dur = data[ix].d * 1000, ea = data[ix].e ?? (t => t);
				if (coroutines[id] !== val)
					return;
				while (elapsed < dur)
				{
					let obj = data[ix].v ? Object.fromEntries(Object.entries(data[ix].v).map(([k, [s, e]]) => [k, (e-s)*ea(elapsed/dur) + s])) : null;
					if (fnc)
						fnc(obj, ix, false);
					if (data[ix].fn)
						data[ix].fn(obj, ix, false);
					elapsed = (await new Promise(requestAnimationFrame)) - startTime;
					if (coroutines[id] !== val)
						return;
				}
				if (fnc)
					fnc(data[ix].v ? Object.fromEntries(Object.entries(data[ix].v).map(([k, v]) => [k, v[1]])) : null, ix, true);
			}
		}

		let fetchCache = {};
		async function doFetch(url, fn)
		{
			if (url in fetchCache)
				return fn ? fn(fetchCache[url]) : fetchCache[url];
			let response = await fetch(url);
			return	response.status === 403 ? false :
				response.status === 200 ? (r => fn ? fn(r) : r)(fetchCache[url] = await response.text()) :
				alert('Data could not be loaded. Contact your santa!') ?? null;
		}

		function joinSegments(segs, fn)
		{
			let svg = [];
			while (segs.length > 0)
			{
				let seg = segs.pop();
				while (true)
				{
					let extIx = segs.findIndex(sg =>
						((sg.d1 ^ 2) === seg.d1 && sg.c[0] === seg.c[0]) ||
						((sg.d1 ^ 2) === seg.d2 && sg.c[0] === seg.c[seg.c.length - 1]) ||
						((sg.d2 ^ 2) === seg.d1 && sg.c[sg.c.length - 1] === seg.c[0]) ||
						((sg.d2 ^ 2) === seg.d2 && sg.c[sg.c.length - 1] === seg.c[seg.c.length - 1]));
					if (extIx === -1)
					{
						extIx = segs.findIndex(sg =>
							((sg.c[0] === seg.c[0] || sg.c[0] === seg.c[seg.c.length - 1]) &&
								!segs.some(s => (s.c[0] === sg.c[0] && (s.d1 ^ 2) === sg.d1) || (s.c[s.c.length - 1] === sg.c[0] && (s.d2 ^ 2) === sg.d1))) ||
							((sg.c[sg.c.length - 1] === seg.c[0] || sg.c[sg.c.length - 1] === seg.c[seg.c.length - 1]) &&
								!segs.some(s => (s.c[0] === sg.c[sg.c.length - 1] && (s.d1 ^ 2) === sg.d2) ||
								(s.c[s.c.length - 1] === sg.c[sg.c.length - 1] && (s.d2 ^ 2) === sg.d2)))
						);
					}
					if (extIx === -1)
						break;
					let ext = segs[extIx];
					segs.splice(extIx, 1);
					if (seg.c[0] === ext.c[0])
					{
						seg.c.reverse();
						seg.c.pop();
						if (seg.d1 === (ext.d1 ^ 2))
							ext.c.shift();
						seg.c.push(...ext.c);
						seg.d1 = seg.d2;
						seg.d2 = ext.d2;
					}
					else if (seg.c[0] === ext.c[ext.c.length - 1])
					{
						ext.c.pop();
						if (seg.d1 === (ext.d2 ^ 2))
							seg.c.shift();
						ext.c.push(...seg.c);
						ext.d2 = seg.d2;
						seg = ext;
					}
					else if (seg.c[seg.c.length - 1] === ext.c[0])
					{
						seg.c.pop();
						if (ext.d1 === (seg.d2 ^ 2))
							ext.c.shift();
						seg.c.push(...ext.c);
						seg.d2 = ext.d2;
					}
					else if (seg.c[seg.c.length - 1] === ext.c[ext.c.length - 1])
					{
						ext.c.reverse();
						seg.c.pop();
						if (seg.d2 === (ext.d2 ^ 2))
							ext.c.shift();
						seg.c.push(...ext.c);
						seg.d2 = ext.d1;
					}
				}
				let isClosed = seg.c[0] === seg.c[seg.c.length - 1];
				svg.push(`M${seg.c.slice(isClosed ? 1 : 0).map(fn).join(' ')}${isClosed ? 'z' : ''}`);
			}
			return svg.join('');
		}

		function make(id, elemName, attrs, content, parent)
		{
			let force = elemName.startsWith('*');
			if (force) elemName = elemName.substring(1);
			let elem = document.getElementById(id) ?? (function()
			{
				let e = document.createElementNS('http://www.w3.org/2000/svg', elemName);
				e.id = id;
				if (!force)
					for (let key in attrs)
						if (attrs.hasOwnProperty(key) && !key.startsWith('*'))
						{
							if (typeof attrs[key] === 'function' && key.startsWith('on'))
								e[key] = attrs[key];
							else if (typeof attrs[key] === 'function')
								e.setAttribute(key, attrs[key]());
							else
								e.setAttribute(key, attrs[key]);
						}
				return e;
			})();
			for (let key in attrs)
				if (attrs.hasOwnProperty(key) && (key.startsWith('*') || force))
				{
					if (typeof attrs[key] === 'function' && /^\*?on/.test(key))
						elem[key.replace(/^\*/, '')] = attrs[key];
					else if (typeof attrs[key] === 'function')
						elem.setAttribute(key.replace(/^\*/, ''), attrs[key]());
					else
						elem.setAttribute(key.replace(/^\*/, ''), attrs[key]);
				}
			(parent ?? vis).appendChild(elem);
			if (content !== undefined)
			{
				if (Array.isArray(content))
					elem.textContent = content[0];
				else
					elem.innerHTML = content;
			}
			return elem;
		}

		document.addEventListener('DOMContentLoaded', async function()
		{
			if (!localStorage || !localStorage.getItem || !localStorage.setItem)
				return alert('This page requires access to local storage.');

			let lights = [[0, 1, 2, 3], [5, 6, 7, 8], [9, 10, 11, 12], [14, 15, 16, 17], [18, 19, 20, 21], [23, 24, 25, 26], [27, 28, 29, 30, 31, 32, 33, 34, 35], [39, 40, 41], [45, 46, 47, 48, 49, 50, 51, 52, 53], [54, 55, 56, 57], [59, 60, 61, 62], [63, 64, 65, 66], [68, 69, 70, 71], [72, 73, 74, 75], [77, 78, 79, 80], [0, 9, 18, 27], [1, 10, 19, 28], [2, 11, 20, 29], [3, 12, 21, 30, 39, 48, 57, 66, 75], [5, 14, 23, 32, 41, 50, 59, 68, 77], [6, 15, 24, 33], [7, 16, 25, 34], [8, 17, 26, 35], [31, 40, 49], [45, 54, 63, 72], [46, 55, 64, 73], [47, 56, 65, 74], [51, 60, 69, 78], [52, 61, 70, 79], [53, 62, 71, 80]];
			function findLightIx(sv) { return lights.findIndex(lg => (lg[0] % w === lg[1] % w) === sv.v && lg.includes(sv.i)); }
			function findLight(sv) { return lights[findLightIx(sv)]; }

			let main = document.getElementById('main'), input = document.getElementById('input'), vis = document.getElementById('vis'), div = document.getElementById('div');
			let state, stateRaw = localStorage.getItem('ppp-state');
			try { state = JSON.parse(stateRaw); } catch { }
			if (Object.prototype.toString.call(state) !== "[object Object]")
				state = {};
			if (!('steps' in state)) state.steps = [];

			let last = JSON.stringify(state.steps[state.step]);

			async function updateView(changes)
			{
				let updated = new Set(), sc = state.steps[state.step], s = sc.v;
				function mk(id, elemName, attrs, content, parent)
				{
					updated.add(id);
					return make(id, elemName, attrs, content, parent);
				}

				function sqxx(x) { return 400 + 100*x; }
				function sqx(i) { return sqxx(i%w); }
				function sqyy(y) { return 150 + 100*y; }
				function sqy(i) { return sqyy((i/w)|0); }

				// Grid
				for (let i = 0; i < w*h; i++)
				{
					let gf = 'hsl(220, 10%, 20%)';
					switch (sc.type)
					{
						case 0:
							if (i === s.i)
								gf = 'hsl(220, 15%, 60%)';
							else if (!lights.some(lg => lg.includes(i)))
								gf = 'black';
							break;
					}
					mk(`sq-${i}`, 'path', { '*fill': gf, d: `M${sqx(i)+2} ${sqy(i)+2}h96v96h-96z` });
				}

				function setupGridInput(fnc)
				{
					for (let y = -1; y <= 10; y++)
						for (let x = -1; x <= 10; x++)
							if (fnc(x, y))
								mk(`inp-${x}-${y}`, 'path', { d: `M${sqxx(x)} ${sqyy(y)}h100v100h-100z`, 'data-x': x, 'data-y': y }, null, input);
				}

				async function render(step)
				{
					let sc = state.steps[step], s = sc.v;
					switch (sc.type)
					{
						case 0:
							let ns = [...new Set(lights.map(lg => lg[0]))];
							ns.sort((a, b) => a-b);
							for (let n = 0; n < ns.length; n++)
								mk(`cw-n-${n}`, 'text', { x: sqx(ns[n])+7, y: sqy(ns[n])+25, fill: 'hsl(220, 10%, 100%)', 'fill-opacity': '.8', 'font-size': '24' }, [n + 1]);
							for (let i = 0; i < w*h; i++)
								if (s.b[i] !== ' ' && s.b[i] !== '_')
									mk(`cw-s-${i}`, 'text', { x: sqx(i)+50, y: sqy(i)+75, fill: 'hsl(220, 10%, 100%)', 'font-size': '64', 'text-anchor': 'middle' }, [s.b[i]]);
							let l = findLight(s);
							mk('cw-hl', 'path', { fill: 'none', stroke: 'hsl(60, 80%, 45%)', 'stroke-width': 4, '*d': `M${sqx(l[0])} ${sqy(l[0])}H${sqx(l[l.length-1])+100}V${sqy(l[l.length-1])+100}H${sqx(l[0])}z` });
							Array.from(document.querySelectorAll('.cw-c')).forEach(c => {
								if (c.dataset.cell === `${s.v ? '↓' : '→'}${l[0]}`)
									c.classList.add('hl');
								else
									c.classList.remove('hl');
							});
							break;

						case 1:
							mk('frame1', 'path', { d: 'M400 150h900v900h-900z', fill: 'none', stroke: 'hsl(220, 20%, 75%)', 'stroke-width': 6 });
							mk('frame2', 'path', { fill: 'none', stroke: 'hsl(220, 20%, 75%)', 'stroke-width': 4, d: () => {
								let sgm = [], W = w+1;
								for (let x = 0; x < w; x++)
									for (let y = 0; y < h; y++)
									{
										if (x < w-1 && sc.b[x + w*y] !== sc.b[x + 1 + w*y])
											sgm.push({ c: [x + 1 + W*y, x + 1 + W*(y+1)], d1: 0, d2: 2 });
										if (y < h-1 && sc.b[x + w*y] !== sc.b[x + w*(y+1)])
											sgm.push({ c: [x + W*(y+1), x + 1 + W*(y+1)], d1: 3, d2: 1 });
									}
								return joinSegments(sgm, c => `${400+100*(c%W)} ${150+100*((c/W)|0)}`);
							} });
							for (let i = 0; i < w*h; i++)
								if (s.b[i] === 'X')
									mk(`cl-${i}-1`, 'image', { href: 'nun.svg', x: sqx(i), y: sqy(i), width: 100, height: 100 });
								else if (s.b[i] === '_')
									mk(`cl-${i}-0`, 'path', { stroke: 'hsl(0, 100%, 75%)', 'stroke-width': 10, opacity: .25, fill: 'none', d: `m${sqx(i)+20} ${sqy(i)+20} 60 60m0-60-60 60` });
							break;

						case 47:
							await render(step - 1);
							let mIx = state.steps.slice(0, step).filter(sp => sp.type === 47).length;
							mk(`mom-${mIx}-r`, '*path', { d: `M${350 + 250*mIx} 1225h250v250h-250z`, fill: 'hsl(38, 100%, 40%)', 'fill-opacity': .5, stroke: 'hsl(38, 85%, 70%)', 'stroke-width': 10, 'paint-order': 'stroke' });
							mk(`mom-${mIx}-t`, '*text', { x: 475 + 250*mIx, y: 1441, fill: 'hsl(38, 100%, 90%)', 'font-family': 'Proxima', 'font-size': 271, 'text-anchor': 'middle' }, [s.b]);
							await document.fonts.ready;
							let cursorX = s.b.length > 0 ? (bb => bb.x+bb.width+20)(document.getElementById(`mom-${mIx}-t`).getBBox()) : 475;
							mk('mom-l', 'path', { '*d': `M${cursorX} 1250v200`, stroke: 'hsl(38, 100%, 90%)', 'stroke-width': 10, 'style': 'animation: .74s infinite blinking-cursor;' });
							break;
					}
				}
				await render(state.step);

				// Previous momentous occasions
				for (let sIx = 0, mIx = 0; sIx < state.steps.length-1; sIx++)
					if (state.steps[sIx].type === 47)
					{
						mk(`mom-${mIx}-r`, '*path', { d: `M${375 + 250*mIx} 1250h200v200h-200z`, fill: 'none', stroke: 'hsl(120, 20%, 80%)', 'stroke-width': 10 });
						mk(`mom-${mIx}-t`, '*text', { x: 475 + 250*mIx, y: 1419, fill: 'hsl(120, 20%, 80%)', 'font-family': 'Proxima', 'font-size': 200, 'text-anchor': 'middle' }, [state.steps[sIx].v.b]);
						mIx++;
					}

				let showCheckBtn = false;
				switch (sc.type)
				{
					case 0:
						setupGridInput((x, y) => x >= 0 && x < w && y >= 0 && y < h && s.b[x+w*y] !== '_');
						showCheckBtn = !s.b.includes(' ');
						break;

					case 1:
						setupGridInput((x, y) => x >= 0 && x < w && y >= 0 && y < h);
						showCheckBtn = s.b.replace(/[^X]/g, '').length === 9;
						break;
				}

				if (showCheckBtn && state.step === state.steps.length - 1)
					mk('check-btn', 'g', { 'class': 'btn', onclick: checkBtnPress }, `
						<circle fill='url(#btn-check-1)' cx='1300' cy='1300' r='150' />
						<circle fill='url(#btn-check-2)' cx='1300' cy='1300' r='130' />
						<text class='btn-text' fill='white' x='0' y='42' filter='url(#shadow)'
							text-anchor='middle' font-size='128' font-family='Work Sans' font-weight='700'>CHECK<${''}/text>
						<text fill='black' x='0' y='70' transform='translate(1300, 1300) rotate(-10)'
							text-anchor='middle' font-size='32' font-family='Work Sans' font-weight='300'>(Enter)<${''}/text>
					`, input);

				// Steps bar
				if (state.steps.length > 1)
				{
					mk('steps-bar', 'path', { fill: 'hsl(222, 10%, 20%)', d: 'M1450 0h1222v150H1450z' });
					for (let i = 0; i < state.steps.length; i++)
					{
						mk(`step-${i}-btn`, 'g', { '*class': `step-btn${i === state.step ? ' sel' : ''}`, 'transform-origin': `${1525 + 80*i} 75` }, `
							<circle cx='${1525 + 80*i}' cy='75' r='40' style='fill: hsl(var(--hue), 50%, 40%)' />
							<circle cx='${1525 + 80*i}' cy='75' r='27' style='fill: hsl(var(--hue), 60%, 80%)' />
							<circle cx='${1525 + 80*i}' cy='75' r='15' style='fill: hsl(var(--hue), 50%, 30%)' />`, input);
						document.getElementById(`step-${i}-btn`).onclick = (st => async () => { state.step = st; setupStep(...await loadStep(st)); })(i);
					}
				}

				for (let thIx = 0; thIx < stepsWithThumbnails.length; thIx++)
					if (state.steps.length > stepsWithThumbnails[thIx])
					{
						let	th = stepsWithThumbnails[thIx], mx = 400, my = 150, tx = 1500, ty = 200 + 250*thIx, x1 = 375, y1 = 125, x2 = x1+950, y2 = y1+950,
							x3 = (x1-400)*2/9+1500, y3 = (y1-150)*2/9+200+250*thIx, x4 = (x2-400)*2/9+1500, y4 = (y2-150)*2/9+200+250*thIx;
						mk(`thumbnail-${th}`, 'g',
							{ 'class': 'thumbnail', transform: `translate(${tx}, ${ty}) scale(${2/9}) translate(${-mx}, ${-my})` },
							await doFetch(thumbnailUrl(th)));
						mk(`show-thumbnail-${th}`, 'g', { style: `opacity: 0; transition: opacity .147s, transform .347s; transform: scale(.9); transform-origin: ${(x3+x4)/2}px ${(y3+y4)/2}px;`, 'data-transform': `scale(.9)` }, `
							<use	opacity='.5'	href='#thumbnail-${th}' transform='translate(${mx}, ${my}) scale(${9/2}) translate(${-tx}, ${-ty})' />
							<path	opacity='.2'	d='M${x1} ${y1} ${x3} ${y3} ${x3} ${y4} ${x1} ${y2}z'	fill='white'	/> <!-- left -->
							<path	opacity='.2'	d='M${x2} ${y1} ${x4} ${y3} ${x4} ${y4} ${x2} ${y2}z'	fill='white'	/> <!-- right -->
							<path	opacity='.3'	d='M${x1} ${y1} ${x2} ${y1} ${x4} ${y3} ${x3} ${y3}z'	fill='white'	/> <!-- top -->
							<path	opacity='.3'	d='M${x1} ${y2} ${x3} ${y4} ${x4} ${y4} ${x2} ${y2}z'	fill='white'	/> <!-- bottom -->
						`);
					}

				for (let obj of Array.from(document.querySelectorAll('#vis>*,#input>*')))
					if (obj.id && !updated.has(obj.id) && !obj.classList.contains('nd'))
						obj.remove();

				if (changes)
				{
					localStorage.removeItem(`ppp-${state.step}-redo`);
					let undo = localStorage.getItem(`ppp-${state.step}-undo`);
					localStorage.setItem(`ppp-${state.step}-undo`, undo ? `${last}\b${undo}` : last);
					last = JSON.stringify(s);
					localStorage.setItem('ppp-state', JSON.stringify(state));
				}
			}

			function setupStep(step, json, html)
			{
				state.step = step;
				div.innerHTML = html ?? '';
				if (!state.steps[step])
					state.steps[step] = JSON.parse(json);
				let sc = state.steps[step], s = sc.v;
				last = JSON.stringify(s);
				switch (sc.type)
				{
					case 0:
						for (let e of Array.from(document.querySelectorAll('div.cw-c')))
							e.onclick = function()
							{
								if (inputBlocked)
									return false;
								let m = /^([→↓])(\d+)$/.exec(e.dataset.cell);
								s.i = m[2]|0;
								s.v = m[1] === '↓';
								updateView();
								return false;
							};
						break;
				}
				localStorage.setItem('ppp-state', JSON.stringify(state));
				updateView();
			}

			function getAnswer(step)
			{
				let inf = state.steps[step-1];
				switch (inf.type)
				{
					case 0:	return inf.v.b;
					case 1:	return inf.v.b.replace(/ /g, '_');
					case 47:	return inf.v.b;
				}
			}

			async function loadStep(step)
			{
				return await doFetch(`Step${step}/data.txt${step > 0 ? `?answer=${getAnswer(step)}` : ''}`, r => [step, ...r.split(/\r?\n#\r?\n/)]);
			}

			function thumbnailUrl(step)
			{
				return `Step${step}/thumbnail.svg?answer=${getAnswer(step)}`;
			}

			async function checkBtnPress()
			{
				if (state.step < state.steps.length-1)
					return await setupStep(...await loadStep(state.step + 1));

				if (inputBlocked)
					return false;
				let sc = state.steps[state.step], s = sc.v, ifGood, ifWrong;
				let mode = sc.type === 47
					? 1 /* momentous occasion */
					: 0 /* check button */;

				switch (mode)
				{
					case 0:  // check button
						if (document.getElementById('check-btn') === null)
							return false;

						let stops = Array.from(document.querySelectorAll('#btn-check-1>stop, #btn-check-2>stop'));
						let arr = [95, 45, 55, 75];
						for (let i = 0; i < stops.length; i++)
							stops[i].setAttribute('stop-color', `hsl(0, 0%, ${arr[i]}%)`);
						let btnText = document.querySelector('#check-btn>text.btn-text');
						ifGood = async function()
						{
							btnText.textContent = 'GOOD!';
							for (let i = 0; i < stops.length; i++)
								stops[i].setAttribute('stop-color', `hsl(100, 100%, ${arr[i]}%)`);
							await coroutine('check-btn', [{ d: 1.47 }]);
						};
						ifWrong = async function()
						{
							btnText.textContent = 'WRONG';
							for (let i = 0; i < stops.length; i++)
								stops[i].setAttribute('stop-color', `hsl(0, 100%, ${arr[i]}%)`);
							coroutine('check-btn', [
								{ d: 2.47 },
								() => { btnText.textContent = 'CHECK'; },
								{ d: 1.47, v: { h: [0, 38], s: [100, 83] }, fn: t => {
									for (let i = 0; i < stops.length; i++)
										stops[i].setAttribute('stop-color', `hsl(${t.h}, ${t.s}%, ${arr[i]}%)`);
								} }
							]);
						};
						break;

					case 1:  // momentous occasion
						let mIx = state.steps.slice(0, state.step).filter(sp => sp.type === 47).length;
						let r = document.getElementById(`mom-${mIx}-r`), tx = document.getElementById(`mom-${mIx}-t`);
						r.setAttribute('fill',	'hsl(0, 0%, 40%)');
						r.setAttribute('stroke',	'hsl(0, 0%, 70%)');
						tx.setAttribute('fill',	'hsl(0, 0%, 90%)');
						let msg = make(null, 'text', { x: 475 + 250*mIx, y: 1245, fill: 'hsl(0, 100%, 90%)', 'font-family': 'Proxima', 'font-weight': 600, 'font-size': 92, 'text-anchor': 'middle' });
						ifGood = async function()
						{
							msg.textContent = 'GOOD!';
							msg.setAttribute('fill', 'hsl(120, 100%, 90%)');
							document.getElementById('mom-l').remove();
							r.setAttribute('fill',	'hsl(120, 100%, 40%)');
							r.setAttribute('stroke',	'hsl(120, 100%, 70%)');
							tx.setAttribute('fill',	'hsl(120, 100%, 90%)');
							await coroutine('check-btn', [
								{ d: 1.47 },
								{ d: .47, v: { s: [100, 0], o: [1, 0], rss: [100, 20], rsl: [70, 80], tl: [90, 80], s: [50, 0], fs: [271, 200], fy: [1441, 1419] }, e: Easing.OutQuad, fn: t => {
									r.setAttribute('d',	`M${(375-t.s/2) + 250*mIx} ${1250-t.s/2}h${200+t.s}v${200+t.s}h${-200-t.s}z`);
									r.setAttribute('fill-opacity',	t.o/2);
									r.setAttribute('stroke',	`hsl(120, ${t.rss}%, ${t.rsl}%)`);
									tx.setAttribute('fill',	`hsl(120, ${t.rss}%, ${t.tl}%)`);
									tx.setAttribute('font-size',	t.fs);
									tx.setAttribute('y',	t.fy);
									msg.setAttribute('opacity',	t.o);
								} }
							]);
						};
						ifWrong = async function()
						{
							msg.textContent = 'TRY AGAIN';
							r.setAttribute('fill',	'hsl(0, 100%, 40%)');
							r.setAttribute('stroke',	'hsl(0, 100%, 70%)');
							tx.setAttribute('fill',	'hsl(0, 100%, 90%)');
							coroutine('check-btn', [
								{ d: .47 },
								{ d: 1.47, v: { o: [1, 0] }, fn: t => { msg.setAttribute('opacity', t.o); } },
								{ d: 1.47, v: { h: [0, 38], s: [100, 83] }, fn: t => {
									r.setAttribute('fill',	`hsl(${t.h}, 100%, 40%)`);
									r.setAttribute('stroke',	`hsl(${t.h}, ${t.s}%, 70%)`);
									tx.setAttribute('fill',	`hsl(${t.h}, 100%, 90%)`);
								} },
								() => { msg.remove(); }
							]);
						}
						break;
				}

				let result = await loadStep(state.step + 1);
				if (result === false)
					return ifWrong();
				inputBlocked = true;
				await ifGood();
				let thIx = stepsWithThumbnails.indexOf(state.step + 1);
				if (thIx >= 0)
				{
					let svg = await doFetch(thumbnailUrl(state.step + 1));
					let tt = make('temp-thumbnail', 'g', {}, svg);
					await coroutine('swoop-thumbnail', [
						{ d: .47 },
						{ d: .87, v: { x: [400, 1500], y: [150, 200 + 250*thIx], s: [1, 2/9] }, e: Easing.OutQuart,
							fn: t => { tt.setAttribute('transform', `translate(${t.x}, ${t.y}) scale(${t.s}) translate(-400, -150)`); } }
					]);
				}
				inputBlocked = false;
				setupStep(...result);
			}

			setupStep(...await loadStep(state.step ?? 0));

			document.body.addEventListener('keydown', function(e)
			{
				let keycombo = `${e.ctrlKey ? 'Ctrl+' : ''}${e.altKey ? 'Alt+' : ''}${e.shiftKey ? 'Shift+' : ''}${e.code}`, m;

				if (	keycombo === 'Ctrl+KeyZ'	|| keycombo === 'Alt+Backspace'	||	// Undo
					keycombo === 'Ctrl+KeyY'	|| keycombo === 'Ctrl+Shift+KeyZ'	|| keycombo === 'Alt+Shift+Backspace')	// Redo
				{
					if (!inputBlocked)
					{
						let [un, re] = keycombo === 'Ctrl+KeyZ' || keycombo === 'Alt+Backspace' ? ['undo', 'redo'] : ['redo', 'undo'];
						let undo = localStorage.getItem(`ppp-${state.step}-${un}`);
						if (undo !== null)
						{
							let split = undo.split('\b'), redo = localStorage.getItem(`ppp-${state.step}-${re}`), cur = JSON.stringify(state.steps[state.step].v);
							localStorage.setItem(`ppp-${state.step}-${re}`, redo === null ? cur : `${cur}\b${redo}`);
							state.steps[state.step].v = JSON.parse(last = split[0]);
							if (split.length === 1)
								localStorage.removeItem(`ppp-${state.step}-${un}`);
							else
								localStorage.setItem(`ppp-${state.step}-${un}`, split.slice(1).join('\b'));
							localStorage.setItem('ppp-state', JSON.stringify(state));
						}
						updateView();
					}
					e.preventDefault();
					return false;
				}

				if (e.ctrlKey || e.altKey || /^F\d+$/.test(e.key))
					return true;

				if (!inputBlocked)
				{
					let sc = state.steps[state.step], s = sc.v, changes = false;

					if ((keycombo === 'Enter' || keycombo === 'NumpadEnter') && document.getElementById('check-btn') !== null)
						return checkBtnPress();

					switch (sc.type)
					{
						case 0:
							function nextLight()
							{
								for (let ol = findLightIx(s), oi = lights[ol].indexOf(s.i),
									l = (ol+1) % lights.length, i = 0;
									l != ol || i != oi;
									i === lights[l].length - 1 ? (i = 0, l = (l+1) % lights.length) : i++)
									if (s.b[lights[l][i]] === ' ')
									{
										s.i = lights[l][i];
										s.v = lights[l][0] % w === lights[l][1] % w;
										break;
									}
							}

							function cursorMovement(dx, dy)
							{
								for (let x = s.i % w + dx, y = ((s.i / w)|0) + dy;
									x >= 0 && x < w && y >= 0 && y < h;
									x += dx, y += dy)
									if (s.b[x + w*y] !== '_') { s.i = x + w*y; return; }
							}

							switch (keycombo)
							{
								case 'ArrowUp':	cursorMovement(0, -1);	break;
								case 'ArrowRight':	cursorMovement(1, 0);	break;
								case 'ArrowDown':	cursorMovement(0, 1);	break;
								case 'ArrowLeft':	cursorMovement(-1, 0);	break;
								case 'Space':	s.v = !s.v;	break;
								case 'Tab':	nextLight();	break;
								case 'Delete':	s.b = `${s.b.substring(0, s.i)} ${s.b.substring(s.i+1, s.b.length)}`; changes = true; break;
								case 'Shift+Tab':
									for (let ol = findLightIx(s), oi = lights[ol].indexOf(s.i),
										l = (ol+lights.length-1) % lights.length, i = lights[l].length - 1;
										l != ol || i != oi;
										i === 0 ? (l = (l+lights.length-1) % lights.length, i = lights[l].length - 1) : i--)
										if (s.b[lights[l][i]] === ' ') { s.i = lights[l][lights[l].findIndex(c => s.b[c] === ' ')]; s.v = lights[l][0] % w === lights[l][1] % w; break; }
									break;
								case 'Backspace':
									if (s.b[s.i] === ' ')
									{
										let l = findLightIx(s), i = lights[l].indexOf(s.i),
											nl = lights[i === 0 ? (l+lights.length-1) % lights.length : l];
										s.i = nl[i === 0 ? nl.length - 1 : i-1];
										s.v = nl[0] % w === nl[1] % w;
									}
									s.b = `${s.b.substring(0, s.i)} ${s.b.substring(s.i+1, s.b.length)}`;
									changes = true;
									break;

								default:
									if (m = /^Key([A-Z])$/.exec(keycombo))
									{
										s.b = `${s.b.substring(0, s.i)}${m[1]}${s.b.substring(s.i+1, s.b.length)}`;
										changes = true;
										for (let ol = findLightIx(s), oi = lights[ol].indexOf(s.i),
											i = (oi+1) % lights[ol].length, l = i === 0 ? (ol + 1) % lights.length : ol;
											l != ol || i != oi;
											i === lights[l].length - 1 ? (i = 0, l = (l+1) % lights.length) : i++)
											if (s.b[lights[l][i]] === ' ')
											{
												s.i = lights[l][i];
												s.v = lights[l][0] % w === lights[l][1] % w;
												break;
											}
									}
									break;
							}
							break;

						case 47:
							if (s.b.length > 0 && (keycombo === 'Enter' || keycombo === 'NumpadEnter'))
								return checkBtnPress();
							else if (s.b.length < 2 && (m = /^(?:Digit|Numpad)([0-9])$/.exec(keycombo)))
							{
								s.b += m[1];
								changes = true;
							}
							else if (s.b.length > 0 && keycombo === 'Backspace')
							{
								s.b = s.b.substring(0, s.b.length-1);
								changes = true;
							}
							break;
					}

					updateView(changes);
				}
				console.log(keycombo);
				e.preventDefault();
				return false;
			});

			let mouseX = null, mouseY = null, mouseStartX = null, mouseStartY = null;

			function click(x, y, rc)
			{
				let sc = state.steps[state.step], s = sc.v, changes = false, i = x + w*y;
				switch (sc.type)
				{
					case 0: s.v = s.i === (s.i = i) !== s.v; break;
					case 1: let wa = rc ? '_' : 'X'; s.b = `${s.b.substring(0, i)}${s.b[i] === wa ? ' ' : wa}${s.b.substring(i+1, s.b.length)}`; changes = true; break;
				}
				updateView(changes);
			}
			function drag(origX, origY, fromX, fromY, x, y, rc)
			{
				let sc = state.steps[state.step], s = sc.v, changes = false, i = x + w*y, fi = fromX + w*fromY, oi = origX + w*origY;
				if ([0].includes(sc.type))
					return click(x, y, rc);

				switch (sc.type)
				{
					case 1: changes = s.b[i] !== s.b[fi]; s.b = `${s.b.substring(0, i)}${s.b[fi]}${s.b.substring(i+1, s.b.length)}`; break;
				}
				updateView(changes);
			}

			document.body.addEventListener('mousedown', function(e)
			{
				if (!('x' in e.target.dataset))
					return true;
				mouseStartX = mouseX = e.target.dataset.x|0;
				mouseStartY = mouseY = e.target.dataset.y|0;
				click(mouseX, mouseY, e.buttons === 2);
				e.preventDefault();
				return false;
			});
			document.body.addEventListener('mouseup',	function(e) { mouseX = mouseStartX = mouseY = mouseStartY = null;	});
			document.body.addEventListener('click',	function(e) { if (!div.contains(e.target)) e.preventDefault();	});
			document.body.addEventListener('contextmenu',	function(e) { if (!div.contains(e.target)) e.preventDefault();	});

			function setThumbnailOverlay(id, on)
			{
				let el = document.getElementById(`show-${id}`);
				el.style.opacity = on ? 1 : 0;
				el.style.transform = on ? 'none' : el.dataset.transform;
				return true;
			}

			document.body.addEventListener('mouseover', function(e)
			{
				for (let tn of document.querySelectorAll('.thumbnail'))
					if (tn.contains(e.target))
						return setThumbnailOverlay(tn.id, true);
				if (mouseX === null || !('x' in e.target.dataset))
					return true;
				let x = e.target.dataset.x|0, y = e.target.dataset.y|0;
				drag(mouseStartX, mouseStartY, mouseX, mouseY, x, y, e.buttons === 2);
				mouseX = x;
				mouseY = y;
			});
			document.body.addEventListener('mouseout', function(e)
			{
				for (let tn of document.querySelectorAll('.thumbnail'))
					if (tn.contains(e.target))
						return setThumbnailOverlay(tn.id, false);
			});

			document.getElementById('copy').onclick = function()
			{
				let text = JSON.stringify(state, null, 4);
				if (navigator.clipboard)
					navigator.clipboard.writeText(text);
				else
				{
					let textArea = document.createElement('textarea');
					textArea.value = text;
					document.body.appendChild(textArea);
					textArea.focus();
					textArea.select();
					try {
						document.execCommand('copy');
					} catch (err) {
						console.error('Unable to copy to clipboard', err);
					}
					document.body.removeChild(textArea);
				}
			};

			document.addEventListener('paste', async function(e)
			{
				try
				{
					let j = JSON.parse((e.clipboardData || window.clipboardData).getData("text"));
					if ('steps' in j && 'step' in j)
					{
						state = { steps: j.steps, step: j.step };
						setupStep(...await loadStep(state.step));
					}
				}
				catch {}
			});
		});
	</script>
</head>
<body>
	<svg id='main' viewBox='0 0 2672 1503'>
		<defs>
			<linearGradient id='btn-check-1' gradientTransform="rotate(70)">
				<stop offset="0%" stop-color="hsl(38, 83%, 95%)" />
				<stop offset="100%" stop-color="hsl(38, 83%, 45%)" />
			</linearGradient>
			<linearGradient id='btn-check-2' gradientTransform="rotate(70)">
				<stop offset="0%" stop-color="hsl(38, 83%, 55%)" />
				<stop offset="100%" stop-color="hsl(38, 83%, 75%)" />
			</linearGradient>
			<filter id="shadow" x="-100%" y="-100%" width='200%' height='200%' filterUnits="userSpaceOnUse">
				<feDropShadow stdDeviation="10" />
			</filter>
		</defs>
		<g id='ui'>
			<g id='copy' transform-origin='100 100'>
				<circle cx='100' cy='100' r='40' fill='hsl(220, 5%, 50%)' />
				<path fill='hsl(220, 5%, 90%)' d='m 95,73.5 c -3.575047,0 -6.5,2.924953 -6.5,6.5 v 30 c 0,3.57505 2.924953,6.5 6.5,6.5 h 20 c 3.57505,0 6.5,-2.92495 6.5,-6.5 V 80 c 0,-3.575047 -2.92495,-6.5 -6.5,-6.5 z m 0,3 h 20 c 1.96494,0 3.5,1.535058 3.5,3.5 v 30 c 0,1.96494 -1.53506,3.5 -3.5,3.5 H 95 c -1.964942,0 -3.5,-1.53506 -3.5,-3.5 V 80 c 0,-1.964942 1.535058,-3.5 3.5,-3.5 z m -10,7 c -3.575043,0 -6.5,2.924957 -6.5,6.5 v 30 c 0,3.57504 2.924957,6.5 6.5,6.5 h 20 c 3.57504,0 6.5,-2.92496 6.5,-6.5 v -2 h -3 v 2 c 0,1.96494 -1.53506,3.5 -3.5,3.5 H 85 c -1.96494,0 -3.5,-1.53506 -3.5,-3.5 V 90 c 0,-1.96494 1.53506,-3.5 3.5,-3.5 h 2 v -3 z m 10,0 v 3 h 15 v -3 z m 0,5 v 3 h 20 v -3 z m 0,5 v 3 h 17.5 v -3 z m 0,5 v 3 h 12.5 v -3 z m 0,5 v 3 h 20 v -3 z' />
			</g>
		</g>
		<g id='vis'></g>
		<foreignObject x='1750' y='150' width='922' height='1353'>
			<div xmlns="http://www.w3.org/1999/xhtml" id='div'></div>
		</foreignObject>
		<g id='input'></g>
	</svg>
</body>
</html>